import random
from enum import Enum
import numpy as np
from music21 import instrument, metadata, note, stream

# Define drum instruments and states
class DrumInstruments(Enum):
    KICK = 0
    SNARE = 1
    CLOSED_HIHAT = 2
    OPEN_HIHAT = 3
    CLAP = 4
    RIMSHOT = 5
    SNAP = 6
    BASS_808 = 7  # New instrument for 808 bass

class DrumStates(Enum):
    OFF = 0
    ON = 1
    ROLL = 2  # Fast hi-hats/snare rolls

class CellularAutomatonDrumGenerator:
    def __init__(self, pattern_length=64):  # 4 bars at 16th-note resolution
        self.pattern_length = pattern_length
        self.state = np.zeros((len(DrumInstruments), pattern_length), dtype=int)

    def simple(self):
        """Generates a structured simple drum pattern using closed hi-hats, hi-hat rolls, claps, snaps, and rimshots."""
        self.state.fill(DrumStates.OFF.value)

        for position in range(self.pattern_length):
            beat = position % 16

            # Closed hi-hats as the backbone
            if beat % 2 == 0:
                self.state[DrumInstruments.CLOSED_HIHAT.value][position] = DrumStates.ON.value

            # Hi-hat rolls every 8th note occasionally for groove
            if beat in [6, 14] and random.random() > 0.7:
                self.state[DrumInstruments.CLOSED_HIHAT.value][position] = DrumStates.ROLL.value

            # Claps on beats 2 & 4
            if beat in [4, 12]:  
                self.state[DrumInstruments.CLAP.value][position] = DrumStates.ON.value

            # Snaps for additional groove in between claps
            if beat in [5, 13] and random.random() > 0.5:
                self.state[DrumInstruments.SNAP.value][position] = DrumStates.ON.value

            # Rimshots used sparingly as accents
            if beat == 10 and random.random() > 0.5:
                self.state[DrumInstruments.RIMSHOT.value][position] = DrumStates.ON.value

    def complex(self):
        """Enhances the simple beat with structured kicks/808s, focusing on the 4th bar for progression."""
        self.simple()  # Start with the simple beat

        # Randomly choose between kick or 808 bass
        use_kick = random.choice([True, False])
        low_end_instrument = DrumInstruments.KICK if use_kick else DrumInstruments.BASS_808

        for position in range(self.pattern_length):
            beat = position % 16
            bar_number = (position // 16) + 1  # Determine which bar we're in

            # Add low-end (kick or 808) only on strong beats
            if beat in [0, 8]:  
                self.state[low_end_instrument.value][position] = DrumStates.ON.value

            # Add extra emphasis in the 4th bar
            if bar_number == 4 and beat in [4, 10, 12]:
                self.state[low_end_instrument.value][position] = DrumStates.ON.value

            # Snares on backbeats (2 & 4)
            if beat == 8 or (beat in [4, 12] and random.random() > 0.7):
                self.state[DrumInstruments.SNARE.value][position] = DrumStates.ON.value

            # Hi-hat rolls for added complexity in the second half of bars
            if beat in [12, 14] and random.random() > 0.5:
                self.state[DrumInstruments.CLOSED_HIHAT.value][position] = DrumStates.ROLL.value

# Converter to transform the cellular automaton state to a music21 score
class DrumPatternMusic21Converter:
    MIDI_PITCHES = {
        DrumInstruments.KICK:           36,
        DrumInstruments.SNARE:          38,
        DrumInstruments.CLOSED_HIHAT:   44,
        DrumInstruments.OPEN_HIHAT:     46,
        DrumInstruments.CLAP:           39,
        DrumInstruments.RIMSHOT:        37,
        DrumInstruments.SNAP:           40,
        DrumInstruments.BASS_808:       35,
    }

    def to_music21_score(self, state):
        score = stream.Score()
        score.metadata = metadata.Metadata(title="Drum Pattern generated by Cellular Automaton")
        pattern_length = len(state[0])
        for drum_instrument in DrumInstruments:
            part = self._instrument_to_music21_part(drum_instrument, state, pattern_length)
            score.append(part)
        return score

    def _instrument_to_music21_part(self, drum_instrument, state, pattern_length):
        part = stream.Part()
        part.insert(0, instrument.UnpitchedPercussion())
        for position in range(pattern_length):
            drum_state = state[drum_instrument.value][position]
            if drum_state == DrumStates.ON.value:
                drum_note = self._create_drum_note(drum_instrument, duration=0.25, velocity=80)
                part.append(drum_note)
            elif drum_state == DrumStates.ROLL.value:
                part.append(self._create_drum_note(drum_instrument, duration=0.125, velocity=60))
                part.append(self._create_drum_note(drum_instrument, duration=0.125, velocity=80))
            else:
                part.append(note.Rest(quarterLength=0.25))
        return part

    def _create_drum_note(self, drum_instrument, duration, velocity):
        drum_note = note.Note()
        drum_note.pitch.midi = self.MIDI_PITCHES.get(drum_instrument, 0)
        drum_note.duration.quarterLength = duration
        drum_note.volume.velocity = velocity
        drum_note.channel = 9
        return drum_note

# Main function to generate and save the patterns as MIDI files
def main():
    pattern_length = 64  # 4 bars at 16th-note resolution
    drum_generator = CellularAutomatonDrumGenerator(pattern_length=pattern_length)
    music_converter = DrumPatternMusic21Converter()

    # Generate the simple pattern and save it
    print("Generating SIMPLE drum pattern...")
    drum_generator.simple()
    simple_score = music_converter.to_music21_score(drum_generator.state)
    simple_score.write('midi', fp="simple_drum.mid")
    print("Simple MIDI file saved: simple_drum.mid")

    # Generate the complex pattern and save it
    print("Generating COMPLEX drum pattern...")
    drum_generator.complex()
    complex_score = music_converter.to_music21_score(drum_generator.state)
    complex_score.write('midi', fp="complex_drum.mid")
    print("Complex MIDI file saved: complex_drum.mid")

if __name__ == "__main__":
    main()


'''
i can make it so that drums generated seperately, 
simple and complex drums of 44 bars with the correct 
tempo are generated seperately with pattern, some 
4 bars with simple, some with complex and some empty
(initial 4 or 8 bars) since 4 bars are already generated 
we just have to repeat them and use samples for drums.
so one wav file will be generated drums.wav with simple,
complex and silence drums with the sample sounds 
'''

"""from pydub import AudioSegment
import numpy as np

# Load drum samples
samples = {
    "kick": AudioSegment.from_wav("kick.wav"),
    "snare": AudioSegment.from_wav("snare.wav"),
    "hi-hat": AudioSegment.from_wav("hi-hat.wav"),
    "hi-hat-roll": AudioSegment.from_wav("hi-hat-roll.wav"),
    "rim": AudioSegment.from_wav("rim.wav"),
    "clap": AudioSegment.from_wav("clap.wav")
}

# Define tempo (e.g., 120 BPM)
BPM = 120
QUARTER_NOTE_DURATION_MS = (60 / BPM) * 1000  # Convert beats to milliseconds
SIXTEENTH_NOTE_DURATION_MS = QUARTER_NOTE_DURATION_MS / 4  # 16th-note timing

# Generate empty track for 44 bars (assuming 4 beats per bar)
BAR_DURATION_MS = QUARTER_NOTE_DURATION_MS * 4
TOTAL_DURATION_MS = BAR_DURATION_MS * 44
final_audio = AudioSegment.silent(duration=int(TOTAL_DURATION_MS))

# Pre-generated simple and complex drum patterns (example)
simple_pattern = [
    ("hi-hat", 0), ("hi-hat", 500), ("snare", 1000), ("hi-hat", 1500),  # Example timings
]
complex_pattern = [
    ("kick", 0), ("hi-hat", 250), ("snare", 1000), ("hi-hat-roll", 1250), ("rim", 1500)
]

# Define bar structure (first 4 bars empty, then alternating patterns)
bar_structure = ["empty"] * 4 + ["simple"] * 8 + ["complex"] * 8 + ["simple"] * 12 + ["complex"] * 8 + ["simple"] * 4

# Apply patterns to final_audio
for bar_index, pattern_type in enumerate(bar_structure):
    bar_start_time = bar_index * BAR_DURATION_MS  # Start time of the bar
    
    if pattern_type == "simple":
        pattern = simple_pattern
    elif pattern_type == "complex":
        pattern = complex_pattern
    else:
        continue  # Empty bar, no drums

    # Overlay the selected pattern
    for drum, time_offset in pattern:
        final_audio = final_audio.overlay(samples[drum], position=int(bar_start_time + time_offset))

# Export the final drum track
final_audio.export("drums.wav", format="wav")

print("Drum track generated successfully: drums.wav")
"""